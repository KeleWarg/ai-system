#!/usr/bin/env tsx
/**
 * Pre-build script to sync components from database to filesystem
 * This ensures components are bundled in Vercel deployments
 * 
 * Run this before `npm run build` in your build command
 */

import { createClient } from '@supabase/supabase-js'
import { writeFile, mkdir } from 'fs/promises'
import { join } from 'path'
import dotenv from 'dotenv'

// Load environment variables
dotenv.config({ path: '.env.local' })

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY

if (!supabaseUrl || !supabaseServiceKey) {
  console.error('‚ùå Missing Supabase credentials')
  console.error('   NEXT_PUBLIC_SUPABASE_URL:', !!supabaseUrl)
  console.error('   SUPABASE_SERVICE_ROLE_KEY:', !!supabaseServiceKey)
  process.exit(1)
}

const supabase = createClient(supabaseUrl, supabaseServiceKey)

async function syncComponentsFromDatabase() {
  console.log('üì¶ Syncing components from database to filesystem...\n')

  try {
    // Fetch all components from database
    const { data: components, error } = await supabase
      .from('components')
      .select('slug, component_name, code')
      .order('created_at', { ascending: true })

    if (error) {
      throw new Error(`Failed to fetch components: ${error.message}`)
    }

    if (!components || components.length === 0) {
      console.log('‚ÑπÔ∏è  No components found in database')
      return
    }

    console.log(`Found ${components.length} components to sync\n`)

    // Ensure registry directory exists
    const registryPath = join(process.cwd(), 'components', 'registry')
    await mkdir(registryPath, { recursive: true })

    // Write each component file
    const exports: string[] = []
    
    for (const component of components) {
      const { slug, component_name, code } = component
      
      if (!code || !component_name) {
        console.log(`‚ö†Ô∏è  Skipping ${slug}: Missing code or component_name`)
        continue
      }

      const filePath = join(registryPath, `${slug}.tsx`)
      await writeFile(filePath, code, 'utf-8')
      
      exports.push(`export { ${component_name} } from './${slug}'`)
      console.log(`‚úÖ ${slug}.tsx ‚Üí ${component_name}`)
    }

    // Write index.ts with all exports
    const indexPath = join(registryPath, 'index.ts')
    const indexContent = `// Auto-generated registry index
// This file is generated by scripts/prebuild-components.ts
// DO NOT EDIT MANUALLY - Changes will be overwritten

${exports.join('\n')}
`
    await writeFile(indexPath, indexContent, 'utf-8')
    console.log(`\n‚úÖ Updated registry index with ${exports.length} exports`)

    // Write metadata
    const metaPath = join(registryPath, '_meta.json')
    const metaContent = JSON.stringify(
      {
        generatedAt: new Date().toISOString(),
        componentCount: components.length,
        components: components.map(c => ({
          slug: c.slug,
          name: c.component_name,
        })),
      },
      null,
      2
    )
    await writeFile(metaPath, metaContent, 'utf-8')
    console.log(`‚úÖ Updated metadata file\n`)

    console.log(`üéâ Successfully synced ${components.length} components!`)
    console.log(`   Registry: ${registryPath}`)
    console.log(`   Index: ${indexPath}`)
    console.log(`   These components will be bundled in your Vercel deployment.\n`)

  } catch (error) {
    console.error('‚ùå Error syncing components:', error)
    process.exit(1)
  }
}

// Run the sync
syncComponentsFromDatabase()

